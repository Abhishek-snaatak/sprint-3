node {

  // =========================
  // CONFIG
  // =========================
  def GIT_URL    = 'https://github.com/OT-MICROSERVICES/employee-api.git'
  def GIT_BRANCH = 'main'
  def DEBUG_LOG  = "${env.WORKSPACE}/compile_debug.log"
  def BINARY     = 'employee-api'
  def BUILD_PATH = '.'

  // =========================
  // INIT
  // =========================
  sh "mkdir -p ${env.WORKSPACE}"
  sh "touch ${DEBUG_LOG}"

  try {

    // =========================
    // CHECKOUT
    // =========================
    stage('Checkout') {
      echo "Checking out ${GIT_URL} @ ${GIT_BRANCH}"
      git url: GIT_URL, branch: GIT_BRANCH
    }

    // =========================
    // VERIFY GO
    // =========================
    stage('Verify Go Environment') {
      sh '''
        set -xe
        echo ">>> Verifying Go installation" | tee -a compile_debug.log
        go version | tee -a compile_debug.log
        go env GOPATH GOROOT | tee -a compile_debug.log
      '''
    }

    // =========================
    // CLEAN & COMPILE
    // =========================
    stage('Clean & Compile') {
      sh """
        set -xe
        rm -f ${BINARY}

        echo ">>> Downloading dependencies" | tee -a ${DEBUG_LOG}
        go mod download | tee -a ${DEBUG_LOG}

        echo ">>> Building Go binary" | tee -a ${DEBUG_LOG}
        CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
          go build -o ${BINARY} . | tee -a ${DEBUG_LOG}
      """
    }

    // =========================
    // VERIFY OUTPUT
    // =========================
    stage('Verify Compilation Output') {
      sh """
        set -xe
        if [ ! -f ${BINARY} ]; then
          echo "ERROR: Go binary not found!" | tee -a ${DEBUG_LOG}
          exit 20
        fi
        ls -lh ${BINARY}
      """
    }

    // =========================
    // ARCHIVE
    // =========================
    stage('Archive Artifacts') {
      archiveArtifacts artifacts: "${BINARY}", fingerprint: true
      archiveArtifacts artifacts: "compile_debug.log", fingerprint: true
    }

    // =========================
    // SLACK SUCCESS
    // =========================
    stage('Slack Notification (success)') {
      withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK_URL')]) {
        sh '''
          payload=$(cat <<EOF
{
  "blocks": [
    {
      "type": "header",
      "text": { "type": "plain_text", "text": "âœ… BUILD SUCCESS" }
    },
    {
      "type": "section",
      "fields": [
        { "type": "mrkdwn", "text": "*Job:*\\n${JOB_NAME}" },
        { "type": "mrkdwn", "text": "*Build #:*\\n#${BUILD_NUMBER}" },
        { "type": "mrkdwn", "text": "*Triggered By:*\\nJenkins" },
        { "type": "mrkdwn", "text": "*Status:*\\nSUCCESS ðŸŽ‰" }
      ]
    },
    {
      "type": "section",
      "text": {
        "type": "mrkdwn",
        "text": "*Build URL:*\\n<${BUILD_URL}|Open in Jenkins>"
      }
    },
    {
      "type": "context",
      "elements": [
        { "type": "mrkdwn", "text": "ðŸ•’ *Time (IST):* $(date '+%Y-%m-%d %H:%M:%S')" }
      ]
    }
  ]
}
EOF
)
          curl -s -X POST -H "Content-Type: application/json" \
               --data "$payload" "$SLACK_WEBHOOK_URL" || true
        '''
      }
    }

  } catch (err) {

    buildFailed = true
    echo "Build failed: ${err}"

    // =========================
    // SLACK FAILURE
    // =========================
    withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK_URL')]) {
      sh '''
        payload=$(cat <<EOF
{
  "blocks": [
    {
      "type": "header",
      "text": { "type": "plain_text", "text": "âŒ BUILD FAILED" }
    },
    {
      "type": "section",
      "fields": [
        { "type": "mrkdwn", "text": "*Job:*\\n${JOB_NAME}" },
        { "type": "mrkdwn", "text": "*Build #:*\\n#${BUILD_NUMBER}" },
        { "type": "mrkdwn", "text": "*Triggered By:*\\nJenkins" },
        { "type": "mrkdwn", "text": "*Status:*\\nFAILED ðŸš¨" }
      ]
    },
    {
      "type": "section",
      "text": {
        "type": "mrkdwn",
        "text": "*Build URL:*\\n<${BUILD_URL}|Open in Jenkins>"
      }
    },
    {
      "type": "context",
      "elements": [
        { "type": "mrkdwn", "text": "ðŸ•’ *Time (IST):* $(date '+%Y-%m-%d %H:%M:%S')" }
      ]
    }
  ]
}
EOF
)
        curl -s -X POST -H "Content-Type: application/json" \
             --data "$payload" "$SLACK_WEBHOOK_URL" || true
      '''
    }

    throw err

  } finally {

    echo "Pipeline finished. buildFailed=${buildFailed}. Job: ${env.JOB_NAME} #${env.BUILD_NUMBER}"

    // Always try to archive debug log
    try {
      archiveArtifacts artifacts: 'compile_debug.log', allowEmptyArchive: true
    } catch (e) {
      echo "Could not archive compile_debug.log: ${e}"
    }
  }
}
